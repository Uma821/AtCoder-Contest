## A - [Chord](https://atcoder.jp/contests/abc312/tasks/abc312_a)

### 自分の回答
```C++
#include <iostream>
#include <string>
#include <set>
using namespace std;

int main() {
  set<string> cand = {"ACE","BDF","CEG","DFA","EGB","FAC","GBD"};
  string S;
  cin >> S;
  cout << (cand.count(S)?"Yes":"No") << endl;
}
```
setで管理した。別にsetじゃなくてもいいだろう。

### 公式回答
```C++
#include <iostream>
#include <string>
using namespace std;

int main() {
	string s;
	cin >> s;
	if (s == "ACE" or s == "BDF" or s == "CEG" or s == "DFA" or s == "EGB" or s == "FAC" or s == "GBD") cout << "Yes\n";
	else cout << "No\n";
}
```
そのまま並べるのもありか。確かに
```C++
#include <iostream>
#include <string>
using namespace std;

int main() {
	string s;
	cin >> s;
	string t = "ACEGBDFAC";
	cout << (t.find(s) == string::npos ? "No" : "Yes") << '\n';
}
```
順番を "ACE" と "CEG" と "EGB" と "GBD" ... のように並び替えてみて、部分文字列探索の問題に置き換えることができる。なるほどためになる。

## B - [TaK Code](https://atcoder.jp/contests/abc312/tasks/abc312_b)

### 自分の回答
```C++
#include <iostream>
using namespace std;
int main() {
  int N, M;
  cin >> N >> M;
  char S[N][M+1];
  for(int n=0; n<N; ++n)
    cin >> S[n];
    
  char takcode[][10] = {
    "###.?????",
    "###.?????",
    "###.?????",
    "....?????",
    "?????????",
    "?????....",
    "?????.###",
    "?????.###",
    "?????.###"
  };
  for(int i=0; i<N-9+1; ++i) // 開始位置
    for(int j=0; j<M-9+1; ++j) { // 開始位置
      bool flag = true;
      for(int id=0; id<9; ++id)
        for(int jd=0; jd<9; ++jd)
          if(S[i+id][j+jd] != takcode[id][jd] && takcode[id][jd] != '?')
            flag = false;
      if(flag)
        cout << i+1 << ' ' << j+1 << endl;
    }
}
```
問題文中に示されていたTaK Codeをそのまま流用した。見やすくて良いと思った。公式の別解でも同じ手法使ってたので嬉しい。

## C - [Invisible Hand](https://atcoder.jp/contests/abc312/tasks/abc312_c)

### 自分の回答(諦め)
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  long N, M;
  long long A[N], B[M];
  for(long n=0; n<N; ++n)
    cin >> N[n];
  for(long m=0; m<M; ++m)
    cin >> M[m];
  
  sort(A, A+N);
  sort(B, B+M, greater<long long>());
  long long X = 0;
  long n=0; m=M;
  // X 円で売ってもよいと考える売り手の人数が、X 円で買ってもよいと考える買い手の人数以上になるまで
  while(!(n>=(M-m))) { // 初めは0円で売ってもいい
    
  }
}
```
Xを動かして目的の位置の条件を満たす値段を設定する。はずだったがよくわからなくなってしまった。

### 公式回答