## A - [Chord](https://atcoder.jp/contests/abc312/tasks/abc312_a)

### 自分の回答
```C++
#include <iostream>
#include <string>
#include <set>
using namespace std;

int main() {
  set<string> cand = {"ACE","BDF","CEG","DFA","EGB","FAC","GBD"};
  string S;
  cin >> S;
  cout << (cand.count(S)?"Yes":"No") << endl;
}
```
setで管理した。別にsetじゃなくてもいいだろう。

### 公式回答
```C++
#include <iostream>
#include <string>
using namespace std;

int main() {
	string s;
	cin >> s;
	if (s == "ACE" or s == "BDF" or s == "CEG" or s == "DFA" or s == "EGB" or s == "FAC" or s == "GBD") cout << "Yes\n";
	else cout << "No\n";
}
```
そのまま並べるのもありか。確かに
```C++
#include <iostream>
#include <string>
using namespace std;

int main() {
	string s;
	cin >> s;
	string t = "ACEGBDFAC";
	cout << (t.find(s) == string::npos ? "No" : "Yes") << '\n';
}
```
順番を "ACE" と "CEG" と "EGB" と "GBD" ... のように並び替えてみて、部分文字列探索の問題に置き換えることができる。なるほどためになる。

## B - [TaK Code](https://atcoder.jp/contests/abc312/tasks/abc312_b)