## A - [3.14](https://atcoder.jp/contests/abc314/tasks/abc314_a)

### 自分の回答
```C++
#include <iostream>
using namespace std;
int main() {
  char *S = "1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679";
  int N;
  cin >> N;
  cout << "3.";
  for(int i=0; i<N; ++i)
    cout << S[i];
}
```
指定された分だけforで出力

### 公式回答
```C++
#include <string>
#include <iostream>
using namespace std;

int main() {
    string pi = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679";
    int N;
    cin >> N;
    cout << pi.substr(0, N + 2) << endl;
}
```
substrって便利ですね。

## B - [Roulette](https://atcoder.jp/contests/abc314/tasks/abc314_b)

### 自分の回答
```C++
#include <iostream>
#include <vector>
using namespace std;
int main() {
  int N;
  cin >> N;
  
  int Anum[N];
  vector<int> A[N];
  vector<int> Xin[37];
  for(int i=0; i<N; ++i) {
    cin >> Anum[i];
    A[i].resize(Anum[i]);
    for(int j=0; j<Anum[i]; ++j) {
      cin >> A[i][j];
      Xin[A[i][j]].push_back(i);
    }
  }
  
  int X;
  cin >> X;
  int min = 37; // 限界値
  vector<int> result;
  for(auto a: Xin[X]) {
    if(min > Anum[a]) { // 最小値更新
      result.clear();
      min = Anum[a];
      result.push_back(a+1);
    }
    else if(min == Anum[a])
      result.push_back(a+1);
  }
  
  cout << result.size() << endl;
  for(auto a: result) cout << a << ' ';
}
```
入力をそのまま受け取りつつ、予めルーレットの同じマスに掛けた人配列も作っておく。Xでマスを指示されたとき、その人たちの中で掛け数が一番少ない人を作成しながら求め、出力。

### 公式回答
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main(void)
{
    int n, x, c[101];
    vector<int> a[101];
    
    cin >> n;
    for(int i = 1; i <= n; i++){
    	cin >> c[i];
        a[i].resize(c[i]);
        for(int j = 0; j < c[i]; j++) cin >> a[i][j];
    }
    cin >> x;
    
    vector<int> vec;
    for(int i = 1; i <= n; i++){
        for(int j = 0; j < c[i]; j++) if(a[i][j] == x) vec.push_back(i);
    }
    
    int cmin = 37;
    for(auto i : vec) cmin = min(cmin, c[i]);
    
    vector<int> ans;
    for(auto i : vec) if(c[i] == cmin) ans.push_back(i);
    
    cout << ans.size() << endl;
    for(auto b : ans) cout << b << " ";
    cout << endl;
    
    return 0;
}
```
Xが与えられてからXに掛けた人を求める。確かにこのほうが余計なことが無くていいかなと思った。
また、掛け数の最小値を求めた後で掛け人リストを作っている。ソースコードが見やすくて良い。

## C - [Rotate Colored Subsequence](https://atcoder.jp/contests/abc314/tasks/abc314_c)

### 自分の回答
問題文が何を言ってるのか理解できなかった。

### 公式回答
