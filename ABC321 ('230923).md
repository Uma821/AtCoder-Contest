## A - [321-like Checker](https://atcoder.jp/contests/abc321/tasks/abc321_a)

### 自分の回答
```C++
#include <iostream>
#include <string>
using namespace std;
int main() {
  string N;
  cin >> N;
  for(int i=1; i<N.size(); ++i)
    if(N[i-1]<=N[i]) {
      cout << "No" << endl;
      return 0;
    }
  cout << "Yes" << endl;
}
```
321-like Numberはi桁目>(i+1)桁目になるものなので、i桁目<=(i+1)桁目ならNoにする。

## B - [Cutoff](https://atcoder.jp/contests/abc321/tasks/abc321_b)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;
int main() {
  int N, X;
  cin >> N >> X;
  vector<int> A(N-1);
  for(auto &&a: A)
    cin >> a;
  
  sort(A.begin(), A.end());
  if(accumulate(A.begin()+1, A.end(), 0) < X) { // この試験で取れる最大の点数を計算してもX以上になれない
    cout << -1;
    return 0;
  }
  if(accumulate(A.begin(), A.end()-1, 0) >= X) { // 0点を取ってもXを超えられる
    cout << 0;
    return 0;
  }
  cout << (X-accumulate(A.begin()+1, A.end()-1, 0)) << endl; // 今回の得点でX越えしないといけない
}
```
自分が値を入力する番の時点でこの試験で取れる最大点は決まっている。大きい値を入力しても、点数で計算される値はソートした後のS₂+S₃​+⋯+SN−1であるために、​SNに該当するため計算に入らないからである。
よって、先ほどの合計値を計算してもX以上にならないのであればもう不可能なので-1、最低点0を取った場合にはS₁に該当するため同様計算に入らない。この場合の合計値はbegin()～end()-1で求められ、既にXを超えているなら答えは0でいい。
後の場合は、今回の入力値が計算に入る場合である。begin()+1～end()-1でXから引けば必要な最低値(答え)が得られる。
