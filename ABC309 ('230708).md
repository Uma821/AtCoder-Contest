## A - [Nine](https://atcoder.jp/contests/abc309/tasks/abc309_a)

### 自分の回答
```C++
#include <iostream>
using namespace std;
int main() {
  int A, B;
  cin >> A >> B;
  cout << (((A-1)/3==(B-1)/3)?"Yes\n":"No\n");
}
```
左右の隣接を確認するには3で割った商で比較すればいい。1～3なら0になるので-1している。

### 公式回答
```C++
#include <iostream>
using namespace std;
int main() {
  int A, B;
  cin >> A >> B;
  int ra=(A-1)/3, ca=(A-1)%3;
  int rb=(B-1)/3, cb=(B-1)%3;
  cout << ((ra == rb && ca + 1 == cb)?"Yes\n":"No\n");
}
```
入力A, Bの内A < Bになることは決まっている。これを生かして同じ行、隣の列かどうかチェック。
（あれ、自分の回答左右に隣接すること判定できてなくないか...?????）

#### 別解
```C++
#include <iostream>
using namespace std;
int main() {
  int A, B;
  cin >> A >> B;
  
  bool answer=false;
  if(A==1&&B==2) answer=true;
  if(A==2&&B==3) answer=true;
  if(A==4&&B==5) answer=true;
  if(A==5&&B==6) answer=true;
  if(A==7&&B==8) answer=true;
  if(A==8&&B==9) answer=true;

  cout << (answer?"Yes\n":"No\n");
}
```
A < Bなのであり得る可能性全部挙げてもまだ現実的
```C++
#include <iostream>
using namespace std;
int main() {
  int A, B;
  cin >> A >> B;
  
  cout << ((A%3!=0&&A+1==B)?"Yes\n":"No\n");
}
```
A%3が0じゃないことで、Aが右端に居ないことが確定する。A<Bより、左右隣接するにはA+1がBかをチェックすればいい。

## B - [Rotate](https://atcoder.jp/contests/abc309/tasks/abc309_b)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
int main() {
  int N;
  cin >> N;
  vector<string> B(N);
  for(int i=0; i<N; ++i)
    cin >> B[i];
  
  int temp = B[0][0]; // 左上だけ上書きされるので覚えておく
  for(int i=1; i<N; ++i)
    B[i-1][0] = B[i][0]; // 左端移動
  for(int i=1; i<N; ++i)
    B[N-1][i-1] = B[N-1][i]; // 下移動
  for(int i=N-1; i>0; --i)
    B[i][N-1] = B[i-1][N-1]; // 右端移動
  for(int i=N-1; i>0; --i)
    B[0][i] = B[0][i-1]; // 上移動
  B[0][1] = temp; // 退避した分
  
  for(int i=0; i<N; ++i) {
    for(int j=0; j<N; ++j)
      cout << B[i][j];
    cout << '\n';
  }
}
```
割とそのままの実装だと思う。

### 公式放送回答
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for (int i = 0; i < (n); ++i)
using P = pair<int,int>;

int main() {
  int n;
  cin >> n;
  vector<string> a(n);
  rep(i,n) cin >> a[i];

  vector<P> ps; // 移動させる座標たちをまとめた配列を作る
  rep(i,n-1) ps.emplace_back(0,i);
  rep(i,n-1) ps.emplace_back(i,n-1);
  rep(i,n-1) ps.emplace_back(n-1,n-1-i);
  rep(i,n-1) ps.emplace_back(n-1-i,0);

  vector<string> b = a; 
  int m = ps.size();
  rep(mi,m) {
    auto [i,j] = ps[mi];
    auto [ni,nj] = ps[(mi+1)%m]; // 一つ次次の座標は移動先
    b[ni][nj] = a[i][j];
  }

  rep(i,n) cout << b[i] << endl;
  return 0;
}
```
移動させる座標の組を配列でまとめておいて、それを参照するのが楽。
予め計算して作っておく概念がAtCoder多いなと思った。

## C - [Medicine](https://atcoder.jp/contests/abc309/tasks/abc309_c)

### 私の回答(WA)
```C++
#include <iostream>
#include <map>
using namespace std;
int main() {
  long long N, K;
  cin >> N >> K;
  map<long long, long long> m;
  for(long long i=0, k, v; i<N; ++i) {
    cin >> k >> v;
    m.insert({k, v});
  }
  
  long long sum=0;
  for(auto rv_itr = m.rbegin(); rv_itr != m.rend(); ++rv_itr) {
    sum += rv_itr->second;
    if(sum > K) {
      cout << rv_itr->first+1;
      return 0;
    }
  }
  cout << 1;
}
```
mapは昇順ソートされるので、末尾から加算してKを超えたときに、その翌日を答えにすればいいはず。なんでこれでWAになるんだろう？？

### 公式回答
```C++
#include <bits/stdc++.h>
using namespace std;

int main() {
    
	int N,K;
	cin>>N>>K;
	
	vector<pair<int,int>> p(N);
	
	for(int i=0;i<N;i++){
		cin>>p[i].first>>p[i].second;
	}
	
	sort(p.begin(),p.end());
	
	long long sum = 0;
	
	for(int i=0;i<N;i++){
		sum += p[i].second;
	}
	
	if(sum<=K)cout<<1<<endl;
	else{
		for(int i=0;i<p.size();i++){
			if(sum<=K){
				cout<<p[i-1].first+1<<endl;
				return 0;
			}
			sum -= p[i].second;
		}
		cout<<p.back().first+1<<endl;
	}
	
	return 0;
}
```
うん？前から探索するか後ろから探索するかだけの違いではないか？？？何が違うんだ...