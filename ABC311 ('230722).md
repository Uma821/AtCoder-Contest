## A - [First ABC](https://atcoder.jp/contests/abc311/tasks/abc311_a)

### 自分の回答
```C++
#include <iostream>
using namespace std;
int main() {
  int N;
  cin >> N;
  char S[N+1];
  cin >> S;
  
  int i;
  int abc_flag = 0;
  for(i=0; i<N; ++i) {
    abc_flag |= (1<<(S[i]-'a'));
    if(abc_flag==((1<<0)+(1<<1)+(1<<2)))
      break;
  }
  
  cout << i+1;
}
```
今まで何の文字が出現してきたかをフラグ管理する。結構そのままの実装だと思う。

### 公式回答
```C++
#include <iostream>
#include <set>
using namespace std;
int main() {
  int N;
  cin >> N;
  char S[N+1];
  cin >> S;
  
  set<char> s;
  int i;
  for(i=0; i<N; ++i) {
    s.insert(S[i]);
    if(s.size()==3)
      break;
  }
  
  cout << i+1;
}
```
出現文字はA,B,Cのいずれかなので、1文字ずつsetに追加してsizeが3になった時が答え。
#### 別解
```C++
#include <iostream>
#include <string.h>
#include <algorithm>
using namespace std;
int main() {
  int N;
  cin >> N;
  char S[N+1];
  cin >> S;
  
  cout << max({strchr(S, 'A'), strchr(S, 'B'), strchr(S, 'C')})-S+1;
}
```
左側からA,B,Cの位置を検索して一番遠いインデックス+1。strchrは実際に見つかるアドレスを返すのでSで引く。

## B - [Vacation Together](https://atcoder.jp/contests/abc311/tasks/abc311_b)

### 自分の回答
```C++
#include <iostream>
using namespace std;
int main() {
  int N, D;
  cin >> N >> D;
  char S[N][D+1];
  
  for(int i=0; i<N; ++i)
    cin >> S[i];
  char ok[D+1]; // 全員がokなスケジュール
  for(int i=0; i<D; ++i) {
    ok[i] = 'o';
    for(int j=0; j<N; ++j)
      if(S[j][i] == 'x')
        ok[i] = 'x';
  }
  ok[D] = '\0'; // なんとなく(oの連続チェックではみ出さないガード役)
  
  int max = 0;
  for(int i=0; i<D; ++i) {
    int ok_s = 0; // okが連続した日数
    for(; ok[i] == 'o'; ++ok_s, ++i); // 
    if(max < ok_s)
      max = ok_s;
  }
  cout << max;
}
```
N人全体の暇なスケジュール配列を作り、連続で暇な日数を計算する。愚直な実装。

#### 改良案
```C++
#include <iostream>
using namespace std;
int main() {
  int N, D;
  cin >> N >> D;
  char S[N][D+1];
  
  for(int i=0; i<N; ++i)
    cin >> S[i];
  char (&ok)[D+1] = S[0]; // 全員がokなスケジュール
  for(int i=0; i<D; ++i) {
    for(int j=1; j<N; ++j)
      if(S[j][i] == 'x')
        ok[i] = 'x';
  }
  
  int max = 0, ok_s = 0; // okが連続した日数
  for(int i=0; i<D; ++i) {
    if(ok[i] == 'o') ++ok_s;
    else ok_s = 0; // リセット
    if(max < ok_s)
      max = ok_s;
  }
  cout << max;
}
```
わざわざ2重ループにせずとも、部分文字列を数え切らなくても途中でmaxを更新してもいいんじゃないかという話。あとok配列をS[0]から流用してみた。使用メモリの削減ができるかと思えば逆に増えたりした。

## C - [Find it!](https://atcoder.jp/contests/abc311/tasks/abc311_c)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <map>
#include <set>
#include <sstream>
using namespace std;
struct graph {
  int start;
  graph *next;
};
void print(vector<graph> &vec, int start) {
  stringstream ss;
  ss << start;
  graph *p = vec[start-1].next;
  int cnt=1;
  while(p->start != start) {
    ss << ' ' << (p->start);
    p = p->next;
    ++cnt;
  }
  cout << cnt << '\n' << ss.str();
}
int main() {
  int N;
  cin >> N;
  vector<graph> vec(N);
  for(int i=0, A; i<N; ++i) {
    cin >> A;
    vec[i] = {i+1, &vec[A-1]};
  }
  
  set<int> cand, selected;
  for(int i=0; i<N; ++i)
    cand.insert(i+1);
  while(cand.size()) {
    int head = *cand.begin();
    while(1) {
      selected.insert(head);
      cand.erase(head);
      graph *next = vec[head-1].next;
      if(selected.count(next->start)) {
        print(vec, next->start);
        return 0;
      }
      head = next->start;
    }
  }
}
```