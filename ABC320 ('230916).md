## B - [Longest Palindrome](https://atcoder.jp/contests/abc320/tasks/abc320_b)

### 自分の回答
```C++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
int main() {
  string S;
  cin >> S;
  int ans = 0;
  for(int i=0; i<S.size(); ++i) {
    for(int j=i+1; j<=S.size(); ++j) {
      string sv{S.begin()+i, S.begin()+j};
      string t = sv;
      reverse(t.begin(), t.end());
      if(sv == t)
        ans = max(ans, j-i);
    }
  }
  cout << ans << endl;
}
```
どの地点を切り取って回文チェックするかを全探索する．

### 公式回答
```C++
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

bool is_palindrome(string s) {
	int n = s.size();
	for (int i = 0; i < n; i++) if (s[i] != s[n - i - 1]) return false;
	return true;
}

int main() {
	string s;
	cin >> s;
	int n = s.size();
	int ans = 1;
	for (int i = 0; i < n; i++) {
		for (int j = i + 1; j <= n; j++) {
			string t = "";
			for (int k = i; k < j; k++) t += s[k];
			if (is_palindrome(t)) ans = max(ans, j - i);
		}
	}
	cout << ans << '\n';
}
```
reverseを使わない場合．reverse使った方が見やすくて良いな．

## C - [Slot Strategy 2 (Easy)](https://atcoder.jp/contests/abc320/tasks/abc320_c)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
int main() {
  int M;
  cin >> M;
  string S1, S2, S3;
  cin >> S1 >> S2 >> S3;
  
  S1 = S1+S1+S1;
  S2 = S2+S2+S2;
  S3 = S3+S3+S3;
  
  long ans = -1;
  for(int i=0; i<10; ++i) {
    string::size_type find_id[] = {S1.find('0'+i), S2.find('0'+i), S3.find('0'+i)};
    while(find_id[0]==find_id[1] || find_id[1]==find_id[2] || find_id[2]==find_id[0]) {
      // cout << find_id[0] << ',' << find_id[1] << ',' << find_id[2] << endl;
      if(find_id[0]==string::npos || find_id[1]==string::npos || find_id[2]==string::npos) // このiではスロット合わせられない
        break;
      if(find_id[0]==find_id[1] && find_id[1]==find_id[2]) {
        vector<string::size_type> v = {S1.find('0'+i, find_id[0]+1), S2.find('0'+i, find_id[0]+1), S3.find('0'+i, find_id[0]+1)}; // 誰か近い人に譲歩してもらう
        find_id[min_element(v.begin(), v.end()) - v.begin()] = *min_element(v.begin(), v.end());
      }
      else if(find_id[0]==find_id[1]) {
        if(S1.find('0'+i, find_id[0]+1) == min(S1.find('0'+i, find_id[0]+1),S2.find('0'+i, find_id[0]+1)))
          find_id[0] = S1.find('0'+i, find_id[0]+1);
        else find_id[1] = S2.find('0'+i, find_id[0]+1);
      }
      else if(find_id[1]==find_id[2]) {
        if(S2.find('0'+i, find_id[1]+1) == min(S2.find('0'+i, find_id[1]+1),S3.find('0'+i, find_id[2]+1)))
          find_id[1] = S2.find('0'+i, find_id[1]+1);
        else find_id[2] = S3.find('0'+i, find_id[1]+1);
      }
      else if(find_id[2]==find_id[0]) {
        if(S3.find('0'+i, find_id[0]+1) == min(S1.find('0'+i, find_id[0]+1),S3.find('0'+i, find_id[0]+1)))
          find_id[2] = S3.find('0'+i, find_id[0]+1);
        else find_id[0] = S1.find('0'+i, find_id[0]+1);
      }
    }
    if(find_id[0]==string::npos || find_id[1]==string::npos || find_id[2]==string::npos) // このiではスロット合わせられない
      continue;
    else if(ans == -1) ans = max({find_id[0], find_id[1], find_id[2]});
    else ans = min(ans, (long)max({find_id[0], find_id[1], find_id[2]}));
  }
  cout << ans << endl;
}
```
3つのロールは同じ長さであり，同時に高々1つしか止めることができないので，もしロールが3周するまでに数字が揃えられなければ永遠に揃えられない(それぞれのロールで止めるべき場所・添え字が異なるなら，1周で終わる．全て同じ添え字で止めなければならないなら，3周すれば完了する)．
なので私はロールとして与えられた文字列を3倍しておいた．この後で，それぞれの添え字が別々且つ，最小になるように3つ選択する必要がある．findを行っておき，もし添え字が被った時に次に同じ数字になるのが早く来るロールに，添え字を変更する．これを繰り返して答えを求める．
ただわかりにくすぎる．

### 公式回答
```C++
#include <bits/stdc++.h>
using namespace std;
#define rep(i,n) for (int i = 0; i < (n); ++i)

int main() {
  int m;
  cin >> m;
  vector<string> s(3);
  rep(i,3) cin >> s[i];

  const int INF = 1001001001;
  int ans = INF;
  rep(t0,300)rep(t1,300)rep(t2,300) {
    if (t0 == t1) continue;
    if (t0 == t2) continue;
    if (t1 == t2) continue;
    if (s[0][t0%m] != s[1][t1%m]) continue;
    if (s[0][t0%m] != s[2][t2%m]) continue;
    ans = min(ans, max({t0,t1,t2}));
  }
  if (ans == INF) ans = -1;
  cout << ans << endl;
  return 0;
}
```