## B - [racecar](https://atcoder.jp/contests/abc307/tasks/abc307_b)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <string>
using namespace std;
bool func(string S) {
  int l=0, r=S.size()-1;
  while(l<r) {
    if(S[l]!=S[r])
      return false;
    ++l;--r;
  }
  return true;
}
int main() {
  int N;
  cin >> N;
  vector<string> S(N);
  for(auto &&s: S)
    cin >> s;
  
  for(int i=0; i<N-1; ++i) {
    for(int j=i+1; j<N; ++j) {
      if(func(S[i]+S[j]) || func(S[j]+S[i])) {
        cout << "Yes\n";
        return 0;
      }
    }
  }
  cout << "No\n";
}
```
iとjを全ての場合で選んで回文かどうかを試す素朴な実装

### 公式回答
```C++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

bool isPalindrome(const string &s) {
  string t = s;
  reverse(t.begin(), t.end());
  return s == t;
}

int main() {
  int n;
  cin >> n;
  vector<string> s(n);
  for(int i=0; i<n; ++i)
    cin >> s[i];
  for(int i=0; i<n; ++i)
    for(int j=0; j<n; ++j) {
      if(i == j) continue;
      string t = s[i]+s[j];
      if(isPalindrome(t)) {
        cout << "Yes" << endl;
        return 0;
      }
    }
  cout << "No" << endl;
  return 0;
}
```
reverseで簡単に逆順にできる。なるほど

## C - [Ideal Sheet](https://atcoder.jp/contests/abc307/tasks/abc307_c)

### 自分の回答
```C++
#include <vector>
#include <string>
#include <iostream>
using namespace std;
int main() {
  int Ha, Wa;
  cin >> Ha >> Wa;
  vector<string> A(Ha);
  for(auto &&a: A)
    cin >> a;
  int Hb, Wb;
  cin >> Hb >> Wb;
  vector<string> B(Hb);
  for(auto &&b: B)
    cin >> b;
  int Hx, Wx;
  cin >> Hx >> Wx;
  vector<string> X(Hx);
  for(auto &&x: X)
    cin >> x;
  
  for(int i=0, leni=max(Ha,Hb); i<leni; ++i) {
    for(int j=0, lenj=max(Wa,Wb); j<lenj; ++j) {
      vector<string> C(2*Hx+Ha+Hb-i);
      for(auto &&c: C) {
        
      }
    }
  }
}
```
Xの端からA, Bを1マスずつ動かしながら全探索してXと合致するかを確かめる。実装直が足りなくて無理だった。

### 公式回答(自分の回答寄りに改変)
シートA, B, Xはそれぞれ少なくとも1つ以上の黒いマスを含むため、Xを比較するためのAB合わせて切り出すシートは黒マスすべて含む必要があることから、必ず切り出すシートはA，B少なくとも1マス以上共有する。
```C++
#include <vector>
#include <string>
#include <iostream>
using namespace std;
int main() {
  int Ha, Wa;
  cin >> Ha >> Wa;
  vector<string> A(Ha);
  for(auto &&a: A)
    cin >> a;
  int Hb, Wb;
  cin >> Hb >> Wb;
  vector<string> B(Hb);
  for(auto &&b: B)
    cin >> b;
  int Hx, Wx;
  cin >> Hx >> Wx;
  vector<string> X(Hx);
  for(auto &&x: X)
    cin >> x;

  // AをXシートの右上ギリギリから左下ギリギリまで移動させる変化の割合Dha, Dwa
  for(int Dha=-Ha+1; Dha<Hx; ++Dha) {
    for(int Dwa=-Wa+1; Dwa<Wx; ++Dwa) {
      // BをXシートの右上ギリギリから左下ギリギリまで移動させる変化の割合Dhb, Dwb
      for(int Dhb=-Hb+1; Dhb<Hx; ++Dhb) {
        for(int Dwb=-Wb+1; Dwb<Wx; ++Dwb) {
          // X上に仮想シートtmpを作成して構成する
          vector tmp(Hx, string(Wx, '.'));
          bool flag = true;
          for(int i=0; i<Ha; ++i) {
            for(int j=0; j<Wa; ++j) {
              if(A[i][j] == '#') { // 仮想シートtmpに#全て配置する必要
                if(i+Dha < 0 || i+Dha >= Hx) flag = false;
                if(j+Dwa < 0 || j+Dwa >= Wx) flag = false;
                if(flag) tmp[i+Dha][j+Dwa] = '#'; // tmpに入ってるので範囲チェック要らない
              }
            }
          }
          for(int i=0; i<Hb; ++i) {
            for(int j=0; j<Wb; ++j) {
              if(B[i][j] == '#') {
                if(i+Dhb < 0 || i+Dhb >= Hx) flag = false;
                if(j+Dwb < 0 || j+Dwb >= Wx) flag = false;
                if(flag) tmp[i+Dhb][j+Dwb] = '#';
              }
            }
          }
          // できたシートをXと比較
          for(int i=0; i<Hx; ++i) {
            for(int j=0; j<Wx; ++j) {
              if(X[i][j] != tmp[i][j]) flag = false;
            }
          }
          if(flag) {
            cout << "Yes" << endl;
            return 0;
          }
        }
      }
    }
  }
  cout << "No" << endl;
}
```
#### 簡単な実装