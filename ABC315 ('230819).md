## B - [The Middle Day](https://atcoder.jp/contests/abc315/tasks/abc315_b)

### 自分の回答
```C++
#include <iostream>
using namespace std;
int main() {
  int M;
  cin >> M;
  int D[M], sum=0;
  for(int i=0; i<M; ++i) {
    cin >> D[i];
    sum += D[i];
  }
  int mid = sum/2+1;
  for(int i=0; i<M; ++i) {
    if(mid>D[i]) {
      mid-=D[i]; continue;
    }
    printf("%d %d\n", i+1, mid);
    return 0;
  }
}
```
真ん中の日が欲しいんだから、まず真ん中を探すためにすべての日付の合計を2で割り+1する。そしてfor文で真ん中の日がどの月に属するのかを判定する。その月の日数を引いて正であれば次以降の月、0か負であれば今月である。累積和を使って2分探索できなくはないと思うがやっても特に意味がない。

## C - [Flavors](https://atcoder.jp/contests/abc315/tasks/abc315_c)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
int main() {
  long N;
  cin >> N;
  vector<pair<long, long long>> cup(N);
  long maxidx = 0;
  for(long i=0;auto &&[F, S]: cup) {
    cin >> F >> S;
    if(cup[maxidx].second < S)
      maxidx = i;
    i++;
  }
  
  long long Max=0;
  for(long i=0; i<N; ++i) {
    if(maxidx == i) continue;
    if(cup[i].first != cup[maxidx].first)
      Max = max(cup[i].second+cup[maxidx].second, Max);
    else if(cup[i].second > cup[maxidx].second)
      Max = max(cup[i].second+cup[maxidx].second/2, Max);
    else
      Max = max(cup[i].second/2+cup[maxidx].second, Max);
  }
  cout << Max << endl;
}
```
すべてのカップの組み合わせを試すとO(N²)になり、最悪9×10⁵のループが発生してしまってTLEになる。
この問題はカップを2つ選んだ時の幸福度の最大値を求めればいいだけなので、とりあえず一つ目は純粋に幸福度最大なカップを選べばいい。もう一つは同じ味の兼ね合いがあるのでforで確認しながら最大値を求めればいい。

### 公式回答
```C++
#include<bits/stdc++.h>

using namespace std;

int main(){
  int n;
  cin >> n;
  vector<vector<int>> bk(n+1);
  for(int i=0;i<n;i++){
    int f,s;
    cin >> f >> s;
    bk[f].push_back(s);
  }

  int res=0;
  vector<int> best;
  for(int i=1;i<=n;i++){ // 同じ味縛りで最大満足度を調査
    sort(bk[i].begin(),bk[i].end());
    reverse(bk[i].begin(),bk[i].end()); // 降順
    if(bk[i].size()>=2){ // 2つ以上あれば調査
      res=max(res,bk[i][0]+bk[i][1]/2);
    }
    if(bk[i].size()>=1){
      best.push_back(bk[i][0]); // 各味の最大満足度を記録
    }
  }
  sort(best.begin(),best.end());
  reverse(best.begin(),best.end());
  if(best.size()>=2){res=max(res,best[0]+best[1]);} // 別々の味縛りで最大満足度調査
  cout << res << "\n";
  return 0;
}
```
2つを選んだ場合に同じ味か違う味かで満足度の計算が違うので、両者を分けて考えている。味毎に配列を分けて格納して、同じ味だけで見て最大満足度を計算した後に、別々の味での最大満足度を計算して両者を比較している。これはこれでわかりやすくて良いと思った。

## D - [Magical Cookies](https://atcoder.jp/contests/abc315/tasks/abc315_d)

### 自分の回答(WA)
```C++
#include <iostream>
#include <vector>
#include <string>
#include <set>
using namespace std;
int main() {
  int H, W;
  cin >> H >> W;
  vector<string> C(H);
  for(auto &&S: C)
    cin >> S;
    
  for(auto &&S: C) {
    set<char> s(S.begin(), S.end());
    s.erase('.');
    if(s.size() != 1) continue;
    s;
  }
}
```
取り除く、ってどうやればええんや、と言うところで手が止まってしまった。
取り除ける行・列の選択とその削除の扱いが難しい。