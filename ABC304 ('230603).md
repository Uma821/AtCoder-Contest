## A - [First Player](https://atcoder.jp/contests/abc304/tasks/abc304_a)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;
int main() {
  int N;
  cin >> N;
  vector<string> S(N);
  vector<int> A(N);
  
  for(int i=0; i<N; ++i)
    cin >> S[i] >> A[i];
  
  int min_arg = min_element(A.begin(), A.end())-A.begin();
  for(int i=min_arg; i<N; ++i)
    cout << S[i] << endl;
  for(int i=0; i<min_arg; ++i)
    cout << S[i] << endl;
}
```
全員の年齢で最も若い人の番号(添え字)を求めて、その地点から時計回りに名前を出力

### 公式回答
```C++
#include <iostream>
#include <utility>
using namespace std;

int main(void)
{
  int n, a[100];
  string s[100];
  
  cin >> n;
  for(int i = 0; i < n; i++) cin >> s[i] >> a[i];
  
  pair<int, int> m = {a[0], 0};
  for(int i = 1; i < n; i++) m = min(m, {a[i], i});
  int p = m.second;
  
  for(int i = 0; i < n; i++) cout << s[(p+i)%n] << endl;
  
  return 0;
}
```
pairは比較演算が可能(firstの方が優先)なのでminで最小を求めることができ、secondでその添え字を得ることができる。

## B - [Subscribers](https://atcoder.jp/contests/abc304/tasks/abc304_b)

### 自分の回答
```C++
#include <iostream>
#include <cmath>
using namespace std;
int main() {
  long long N;
  cin >> N;
  if(N < 1000)
    cout << N;
  else {
    auto i = floor(log10(N/100)); // 何桁切り捨てるか
    cout << (N/(long(pow(10,i))))*long(pow(10,i)); // 切り捨てて元に戻す
  }
}
```
小数点無駄に計算してコスパ悪そう

### 解説放送
```C++
#include <iostream>
using namespace std;

int main() {
  long long N;
  cin >> N;
  for(int r=1000;; r*=10) {
    if(N < r) {
      long long w = r/1000;
      cout << N/w*w << endl;
      return 0;
    }
  }
}
```
一発でやろうとすると難しくなり、forの使用を許せば簡潔に記述できる
### 公式回答
```C++
#include <iostream>
using namespace std;

int main() {
	int n;
	cin >> n;
	if (n < 1000) cout << n << '\n';
	if (1000 <= n && n <= 9999) cout << n - n % 10 << '\n';
	if (10000 <= n && n <= 99999) cout << n - n % 100 << '\n';
	if (100000 <= n && n <= 999999) cout << n - n % 1000 << '\n';
	if (1000000 <= n && n <= 9999999) cout << n - n % 10000 << '\n';
	if (10000000 <= n && n <= 99999999) cout << n - n % 100000 << '\n';
	if (100000000 <= n && n <= 999999999) cout << n - n % 1000000 << '\n';
}
```
愚直だが見やすさ100%

```C++
#include <iostream>
using namespace std;
constexpr ll pow10(int n) { return n ? 10 * pow10(n - 1) : 1; };

int main() {
  int n;
  cin >> n;
  if (n < 1000) cout << n << '\n';
  for (int i = 1; i <= 6; i++)
    if (pow10(i + 2) <= n && n < pow10(i + 3))
      cout << n - n % pow10(i) << '\n';
}
```
上記処理をforで纏めたバージョン、pow10で10の累乗を計算する

```C++
#include <iostream>
#include <string>
using namespace std;

int main() {
	string s;
	cin >> s;
	if (s.size() <= 3) cout << s << '\n';
	else cout << s.substr(0, 3) << string(s.size() - 3, '0') << '\n';
}
```
いっそのことstringで実装する手もある

## C - [Virus](https://atcoder.jp/contests/abc304/tasks/abc304_c)
### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <queue>
#include <cmath>
using namespace std;
int main() {
  int N, D;
  cin >> N >> D;
  vector<bool> kansen_array(N, false);
  kansen_array[0] = true;
  vector<pair<int, int>> people(N);
  
  for(int i=0, x, y; i<N; ++i) {
    cin >> x >> y;
    people[i] = make_pair(x, y);
  }
  
  queue<int> kansen({0}); // 0番目は感染者
  while(!kansen.empty()) {
    int id = kansen.front();
    for(int i=0; i<N; ++i) {
      if(kansen_array[i]) continue;
      if(sqrt((people[i].first-people[id].first)*(people[i].first-people[id].first)+(people[i].second-people[id].second)*(people[i].second-people[id].second))<=D) {
        kansen.push(i);
        kansen_array[i] = true;
      }
    }
    kansen.pop();
  }
  
  for(auto kansen: kansen_array) {
    cout << (kansen?"Yes":"No") << endl;
  }
}
```