## B - [Strictly Superior](https://atcoder.jp/contests/abc310/tasks/abc310_b)

### 私の回答(WA)
```C++
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>
using namespace std;
int main() {
  int N, M;
  cin >> N >> M;
  vector<pair<int, set<int>>> P(N);
  for(auto &&p: P) {
    cin >> p.first >> M;
    for(int i=0, tmp; i<M; ++i) {
      cin >> tmp;
      p.second.insert(tmp);
    }
  }
  for(int i=0; i<N-1; ++i) 
    for(int j=i+1; j<N; ++j) {
      if(P[i].first>=P[j].first && // 2つのソート済みイテレータ範囲[first1, last1)と[first2, last2)において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定
         includes(P[j].second.begin(), P[j].second.end(), P[i].second.begin(), P[i].second.end()) &&
         (P[i].first>P[j].first || P[j].second!=P[i].second)) {
        cout << "Yes\n";
        return 0;
      }
      swap(i, j);
      if(P[i].first>=P[j].first && 
         includes(P[j].second.begin(), P[j].second.end(), P[i].second.begin(), P[i].second.end()) &&
         (P[i].first>P[j].first || P[j].second!=P[i].second)) {
        cout << "Yes\n";
        return 0;
      }
    }
  cout << "No\n";
}
```
B問題が解けなかった敗北感。あれ、swapって、iとjの値がそのまま変わるんだよな、for文がバグるよな...???

### 私の回答(バグ修正)
```C++
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>
using namespace std;
int main() {
  int N, M;
  cin >> N >> M;
  vector<pair<int, set<int>>> P(N);
  for(auto &&p: P) {
    cin >> p.first >> M;
    for(int i=0, tmp; i<M; ++i) {
      cin >> tmp;
      p.second.insert(tmp);
    }
  }
  for(int i=0; i<N; ++i) 
    for(int j=0; j<N; ++j) {
      if(i==j) continue; // 同じ商品を比較しても意味ない
      if(P[i].first>=P[j].first && // 2つのソート済みイテレータ範囲[first1, last1)と[first2, last2)において、一方の範囲の要素がもう一方の範囲に全て含まれているかを判定
         includes(P[j].second.begin(), P[j].second.end(), P[i].second.begin(), P[i].second.end()) &&
         (P[i].first>P[j].first || P[j].second!=P[i].second)) {
        cout << "Yes\n";
        return 0;
      }
    }
  cout << "No\n";
}
```
for文がバグらないようにちゃんと0からNまでの2重ループを作った。前の回答だとswapをもう一度やって元に戻す手もあると思われる。横着するとこういうことになる。

### 公式回答
```C++
#include <iostream>
#include <vector>
#include <utility>
#include <algorithm>

using namespace std;

// product_j が product_i の上位互換か判定する
bool is_strictly_superior(const pair<int, vector<int>> &product_i, const pair<int, vector<int>> &product_j) {
    const auto&[price_i, feature_i]{product_i};
    const auto&[price_j, feature_j]{product_j};

    return price_i >= price_j &&
           includes(feature_j.begin(), feature_j.end(), feature_i.begin(), feature_i.end()) &&
           (price_i > price_j || !includes(feature_i.begin(), feature_i.end(), feature_j.begin(), feature_j.end()));
}

// products に上位互換の組があるか判定する
bool has_superior_pair(const vector<pair<int, vector<int>>> &products) {
    return any_of(products.begin(), products.end(), [&products](const auto &product_i) {
        return any_of(products.begin(), products.end(), [&product_i](const auto &product_j) {
            return is_strictly_superior(product_i, product_j);
        });
    });
}

int main() {
    int N, M;
    cin >> N >> M;
    vector<pair<int, vector<int>>> products(N);
    for (auto&&[price, feature] : products) {
        cin >> price;
        int K;
        cin >> K;
        feature = vector<int>(K);
        for (auto &&f : feature)
            cin >> f;
    }

    cout << (has_superior_pair(products) ? "Yes" : "No") << endl;
    return 0;
}
```
なるほどany_ofを使う手もありますね。

## C - [Reversible](https://atcoder.jp/contests/abc310/tasks/abc310_c)

### 自分の回答
```C++
#include <iostream>
#include <string>
#include <algorithm>
#include <set>
#include <list>
using namespace std;
int main() {
  long N;
  cin >> N;
  vector<string> S(N);
  for(auto &&s: S) {
    cin >> s;
  }
  set<string> Set;
  for(auto &&s: S) {
    if(!Set.count(s)) {
      reverse(s.begin(), s.end());
      if(!Set.count(s)) {
        Set.insert(move(s));
      }
    }
  }
  cout << Set.size() << endl;
}
```