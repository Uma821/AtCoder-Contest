## A - [Full Moon](https://atcoder.jp/contests/abc318/tasks/abc318_a)

### 自分の回答
```C++
#include <iostream>
#include <cmath>
using namespace std;
int main() {
  long N, M, P;
  cin >> N >> M >> P;
  cout << floor(double(N-M)/P)+1 << endl;
}
```
最初の満月からの差分を消して、期間内に満月が何回出るか計算している。このままだと初めの満月が0回になるため、+1を行う。また、N<Mの場合0と出力させたいのだが、普通に割ると0方向への丸めになるため割り算がN=2, M=3とかだと割り算が0で答えが1になってしまう。そのためfloorで丸めている。
#### 改良案
```C++
#include <iostream>
#include <cmath>
using namespace std;
int main() {
  long N, M, P;
  cin >> N >> M >> P;
  cout << ((N-M+P)/P) << endl;
}
```
とすると、+1をP/Pとして割り算に組み込んだらfloorが要らなくなる。ちなみに公式回答にはPythonで割り算がされており、Pythonの[切り捨て除算はfloorである為](https://qiita.com/quwtoy/items/d74fbeac4545531f0f0a)問題ない。あと、Mが大きすぎた場合マイナスになるのを防ぐ必要もあったみたいである(テストケースに無かったので引っかからなかった)。
#### 修正案
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  long N, M, P;
  cin >> N >> M >> P;
  cout << max(0l,(N-M+P)/P) << endl;
}
```

## B - [Overlapping sheets](https://atcoder.jp/contests/abc318/tasks/abc318_b)

### 自分の回答
```C++
#include <iostream>
#include <vector>
using namespace std;
int main() {
  int N;
  cin >> N;
  vector Seets(100, vector<bool>(100));
  for(int A, B, C, D, i=0; i<N; ++i) {
    cin >> A >> B >> C >> D;
    while(A!=B) {
      for(int j=C; j<D; ++j) {
        Seets[A][j] = true;
      }
      ++A;
    }
  }
  
  int sum = 0;
  for(int i=0; i<100; ++i)
    for(int j=0; j<100; ++j)
      sum += Seets[i][j];
  cout << sum << endl;
}
```