## A - [Full Moon](https://atcoder.jp/contests/abc318/tasks/abc318_a)

### 自分の回答
```C++
#include <iostream>
#include <cmath>
using namespace std;
int main() {
  long N, M, P;
  cin >> N >> M >> P;
  cout << floor(double(N-M)/P)+1 << endl;
}
```
最初の満月からの差分を消して、期間内に満月が何回出るか計算している。このままだと初めの満月が0回になるため、+1を行う。また、N<Mの場合0と出力させたいのだが、普通に割ると0方向への丸めになるため割り算がN=2, M=3とかだと割り算が0で答えが1になってしまう。そのためfloorで丸めている。
#### 改良案
```C++
#include <iostream>
#include <cmath>
using namespace std;
int main() {
  long N, M, P;
  cin >> N >> M >> P;
  cout << ((N-M+P)/P) << endl;
}
```
とすると、+1をP/Pとして割り算に組み込んだらfloorが要らなくなる。ちなみに公式回答にはPythonで割り算がされており、Pythonの[切り捨て除算はfloorである為](https://qiita.com/quwtoy/items/d74fbeac4545531f0f0a)問題ない。あと、Mが大きすぎた場合マイナスになるのを防ぐ必要もあったみたいである(テストケースに無かったので引っかからなかった)。
#### 修正案
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  long N, M, P;
  cin >> N >> M >> P;
  cout << max(0l,(N-M+P)/P) << endl;
}
```

## B - [Overlapping sheets](https://atcoder.jp/contests/abc318/tasks/abc318_b)

### 自分の回答
```C++
#include <iostream>
#include <vector>
using namespace std;
int main() {
  int N;
  cin >> N;
  vector Seets(100, vector<bool>(100));
  for(int A, B, C, D, i=0; i<N; ++i) {
    cin >> A >> B >> C >> D;
    while(A!=B) {
      for(int j=C; j<D; ++j) {
        Seets[A][j] = true;
      }
      ++A;
    }
  }
  
  int sum = 0;
  for(int i=0; i<100; ++i)
    for(int j=0; j<100; ++j)
      sum += Seets[i][j];
  cout << sum << endl;
}
```
言われた範囲だけでSeetを塗りつぶしてその数を数える．
[2次元imos法](https://atcoder.jp/contests/abc318/editorial/7092)とやらで解けるらしいがよくわかってない

## C - [Blue Spring](https://atcoder.jp/contests/abc318/tasks/abc318_c)

### 自分の回答
```C++
#include <iostream>
#include <vector>
#include <algorithm>
#include <numeric>
using namespace std;
int main() {
  long N, D;
  cin >> N >> D;
  long long P;
  cin >> P;
  vector<long long> F(N);
  for(long i=0; i<N; ++i)
    cin >> F[i];
  
  sort(F.rbegin(), F.rend()); // 価格を高い順に並べる
  for(long i=0; i<N; i+=D) {
	    long long DdayFare = 0; // D日分の通常料金
    for(long j=0; j<D; ++j)
      if(i+j<N) DdayFare += F[i+j];
    if(DdayFare > P) { // 周遊パスの方が得なら
      F[i] = P;
      for(long j=1; j<D; ++j)
        if(i+j<N) F[i+j] = 0;
    }
    else break;
  }
  
  cout << accumulate(F.begin(), F.end(), 0LL) << endl;
}
```
チケット価格が高いもの順に並べて，周遊パスの料金に置き換えられるなら置換える．これを繰り替えす

## D - [General Weighted Max Matching](https://atcoder.jp/contests/abc318/tasks/abc318_d)

### 自分の回答
どう探索すればいいかもわからなかった...

