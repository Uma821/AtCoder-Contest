## A - [To Be Saikyo](https://atcoder.jp/contests/abc313/tasks/abc313_a)

### 自分の回答
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  int N;
  cin >> N;
  int P[N];
  for(int i=0; i<N; ++i)
    cin >> P[i];
  int *max_elem = max_element(P, P+N);
  if(max_elem == P && count(P, P+N, *max_elem)==1) // 自分が最大で，ほかに最大なものがいないとき
    cout << 0;
  else
    cout << *max_elem-P[0]+1; // max(相手)+1にならないといけない
}
```
見返すと、自分と相手の計算が混ざってて判別が大変だな。

### 改良案
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  int N;
  cin >> N;
  int P1, P[N-1];
  cin >> P1;
  for(int i=0; i<N-1; ++i)
    cin >> P[i];
  int *max_elem = max_element(P, P+N-1); // 相手の最大値
  cout << max(0, *max_elem-P1+1); // max(相手)+1にならないといけない
}
```
これで概ね問題ないのだが、対戦相手が自分だけだった場合Pが0要素の配列になってしまう。max_elementも変な値になる可能性が高いので、m=0とか定義して地道に比較して最大値を求めるのが良い。汎用性を考えると、1個多く要素を作って番兵のように使うという手もあると思った。
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  int N;
  cin >> N;
  int P[N+1];
  for(int i=0; i<N; ++i)
    cin >> P[i];
  P[N] = 0; // 番兵
  int &P1 = P[0];
  int *max_elem = max_element(P+1, P+N+1); // 相手の最大値
  cout << max(0, *max_elem-P1+1); // max(相手)+1にならないといけない
}
```

## B - [Who is Saikyo?](https://atcoder.jp/contests/abc313/tasks/abc313_b)

### 自分の回答
```C++
#include <iostream>
#include <set>
using namespace std;
int main() {
  int N, M;
  cin >> N >> M;
  set<int> s;
  for(int i=1; i<=N; ++i)
    s.insert(i);
  for(int i=0, A, B; i<M; ++i) {
    cin >> A >> B;
    s.erase(B); // 下についた時点で最強ではない
  }
  if(s.size() == 1) // 誰の下にもつかなかった人数
    cout << *s.begin();
  else
    cout << -1;
}
```
誰の下に着いたかは考える必要が無くて、誰が下に着いたかだけ考えればいい。消去法である。

### 公式回答
```C++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int N, M;
    cin >> N >> M;
    
    // 負けたことがあるかどうか
    vector<bool> is_lose(N, false);
    
    // M 回対戦
    for (int i = 0; i < M; ++i) {
        int A, B;
        cin >> A >> B;
        --A, --B;
        is_lose[B] = true;
    }
    
    // 無敗の者どもを抽出する
    vector<int> wins;
    for (int i = 0; i < N; ++i) if (!is_lose[i]) wins.push_back(i);
    
    // 出力
    if (wins.size() == 1) cout << wins[0]+1 << endl;  // 1-indexed に
    else cout << -1 << endl;
}
```
確かに別にsetで考えなくてもいいのか。setの削除とvectorの最後の抽出どちらが高速な方がいいのかと考えなければいけないのか。
#### DFS
```C++
#include <bits/stdc++.h>
using namespace std;

// 入力
int N, M;
vector<vector<int>> G;  // グラフ

// DFS
void dfs(int v, vector<bool> &seen) {
    seen[v] = true;
    for (auto v2 : G[v]) {
        if (seen[v2]) continue;
        dfs(v2, seen);
    }
}

int main() {
    // 入力受け取り
    cin >> N >> M;
    G.assign(N, vector<int>());
    for (int i = 0; i < M; ++i) {
        int A, B;
        cin >> A >> B;
        --A, --B;
        G[A].push_back(B);
    }
    
    int res = -1;
    for (int v = 0; v < N; ++v) {
        // 頂点 v を始点とした DFS
        vector<bool> seen(N, false);
        dfs(v, seen);
        
        // すべての頂点が訪問済みとなったかどうかを判定する
        bool ok = true;
        for (int i = 0; i < N; ++i) if (!seen[i]) ok = false;
        if (ok) {
            res = v+1;
            break;
        }
    }
    cout << res << endl;
}
```
一番強いプログラマが居るなら、その頂点から辿ればすべてを訪問できる。という理論。確かにこれでもできるな。

## C - [Approximate Equalization 2](https://atcoder.jp/contests/abc313/tasks/abc313_c)

### 自分の回答
```C++
#include <iostream>
#include <algorithm>
using namespace std;
int main() {
  long N;
  cin >> N;
  long long A[N], sum=0;
  for(int i=0; i<N; ++i) {
    cin >> A[i];
    sum += A[i];
  }
  long long mid = sum/N; // 目標地点 でも切り捨てが起きている(本当の中間はmid+1との間)
  
  long long tooH=0, tooL=0;
  for(int i=0; i<N; ++i) {
    if(mid<A[i])
      tooH+=A[i]-mid-1; // より大きい側はmid+1に合わせることでフェアになる
    else
      tooL+=mid-A[i];
  }
  cout << max(tooH, tooL); // コストを掛けなかった側が合わせる
  
}
```
微妙な実装な気がしている。入力列Aの最小値と最大値の差を1以下にするための最小の操作回数として。まず、目標地点midを考えた。ただ、整数のため切り捨てが起こることを考え、midよりも大きい側はmid+1になる操作回数、mid以下の側はmidになる操作回数を数えた。どちらかの操作回数で、より多く罹った方を答えにして、最小値と最大値の差を1以下にできた。

### 公式回答